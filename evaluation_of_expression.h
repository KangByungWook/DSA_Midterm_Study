#ifndef EVALUATATION_OF_EXPRESSON
#define EVALUATATION_OF_EXPRESSON

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "stack.h"

//postFix : prefix에서 변환된 postfix 문자열이 저장되는 주소 
char postFix[100];
int postFixBuffIndex = 0;
    

int get_precedence(char *oper){
	if(!strcmp(oper, "AND") || !strcmp(oper, "OR"))return 1;
	else if(*oper == '+' || *oper == '-') return 2;
	else if(*oper == '*' || *oper == '/') return 3;
	else if(*oper == '(' || *oper == ')') return 4;
	else return -1;
}

char* prefix_to_postfix(char *str){
	char tmp[100];
	int num_of_char, len, i, start_index;
	len=strlen(str);
	element newElement;
    for(i=0;i<len;i++)
    {   
		start_index = i;
        num_of_char = 1; 
    	//숫자인 경우	
        if('0'<=str[i] && str[i]<='9'){
        	// 뒤에 숫자가 더 있는 경우(2의자리 이상) 
        	while('0'<=str[i+1] && str[i+1]<='9'){
        		num_of_char++;
        		i++;
        	};
        	// 숫자 문자열이 저장될 tmp 에 숫자 문자열을 저장 
			strncpy(tmp, str+start_index,num_of_char);
			// 마지막 메모리 공간에 null문자 삽입 
			tmp[num_of_char] = '\0';
			
			strcat(postFix, tmp);
			strcat(postFix, " ");
			
			printf("%d", atoi(tmp));
        }
        //연산자인 경우  
        else{
        	// 연산자 자리 수가 1이상인 AND 또는 OR인 경우. 
			while('0'> str[i+1] || str[i+1] > '9'){
				// 그러나 )* 와 같은 경우는 각각이 하나이므로 따로 처리.
				// 즉 하나로 보면 안됨 
        		if(str[i+1] == '*' || str[i+1] == '/' || str[i+1] == '+' || str[i+1] == '-' || str[i+1] == '(' || str[i+1] == ')')break;
        		
        		num_of_char++;
        		i++;
        	};
			strncpy(tmp, str+start_index,num_of_char);
			
        	tmp[num_of_char] = '\0';
        	while(!isEmpty(stack) && stack[top].precedence >= get_precedence(tmp)){
        		
        		printf("%s", stack[top].oper);
        		
        		strcat(postFix, stack[top].oper);
				strcat(postFix, " ");
				
        		Pop(&top);
			}
			strcpy(newElement.oper,tmp);
			newElement.precedence = get_precedence(tmp);
			Push(&top, newElement);
        	}
	}
    while(!isEmpty(stack)){
    	printf("%s", stack[top].oper);
    	
		strcat(postFix, stack[top].oper);
		strcat(postFix, " ");
		
    	Pop(&top);
	}
	return postFix;	
}


#endif
